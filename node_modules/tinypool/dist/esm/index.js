import{a as t,b as m,c as A,d as E,e as W,f as y,g as T,h as v,i as U,j as z,k as C,l as ve,m as Q,n as F,o as j}from"./chunk-NBICOIEE.js";import{Worker as oe,MessageChannel as ae,receiveMessageOnPort as ue}from"worker_threads";import{once as le}from"events";import{EventEmitter as ne}from"events";import{AsyncResource as ie}from"async_hooks";var M=Symbol("kEventEmitter"),S=Symbol("kAsyncResource"),Ee,B=class extends ie{constructor(e,s,r){super(s,r);t(this,Ee);this[M]=e}get eventEmitter(){return this[M]}};Ee=M;var Re,_=class extends ne{constructor(e){let s;typeof e=="string"?(s=e,e=void 0):s=e?.name||new.target.name;super(e);t(this,Re);this[S]=new B(this,s,e)}emit(e,...s){return this.asyncResource.runInAsyncScope(super.emit,this,e,...s)}emitDestroy(){this.asyncResource.emitDestroy()}asyncId(){return this.asyncResource.asyncId()}triggerAsyncId(){return this.asyncResource.triggerAsyncId()}get asyncResource(){return this[S]}static get EventEmitterAsyncResource(){return _}},D=_;Re=S;var N=D;import{AsyncResource as me}from"async_hooks";import{cpus as he}from"os";import{fileURLToPath as q,URL as ce}from"url";import{dirname as fe,join as de,resolve as ke}from"path";import{inspect as V,types as pe}from"util";import R from"assert";import{performance as w}from"perf_hooks";import{readFileSync as ge}from"fs";var J=he().length;function be(o,e){"addEventListener"in o?o.addEventListener("abort",e,{once:!0}):o.once("abort",e)}var P=class extends Error{constructor(){super("The task has been aborted")}get name(){return"AbortError"}},O=class{constructor(){t(this,"tasks",[])}get size(){return this.tasks.length}shift(){return this.tasks.shift()}push(e){this.tasks.push(e)}remove(e){let s=this.tasks.indexOf(e);R.notStrictEqual(s,-1),this.tasks.splice(s,1)}},$={filename:null,name:"default",minThreads:Math.max(J/2,1),maxThreads:J*1.5,idleTimeout:0,maxQueue:1/0,concurrentTasksPerWorker:1,useAtomics:!0,taskQueue:new O,trackUnmanagedFds:!0},ye={transferList:void 0,filename:null,signal:null,name:null},k,Y=class{constructor(e){A(this,k,void 0);E(this,k,e)}get[y](){return m(this,k)}get[T](){return m(this,k)}};k=new WeakMap;var p,G=class{constructor(e){A(this,p,void 0);E(this,p,e)}get[y](){return m(this,p).buffer}get[T](){return m(this,p)}};p=new WeakMap;var Te=0;function H(o){return o.startsWith("file:")?q(new ce(o)):o}var K=class extends me{constructor(e,s,r,a,f,l,i){super("Tinypool.Task",{requireManualDestroy:!0,triggerAsyncId:i});t(this,"callback");t(this,"task");t(this,"transferList");t(this,"filename");t(this,"name");t(this,"taskId");t(this,"abortSignal");t(this,"abortListener",null);t(this,"workerInfo",null);t(this,"created");t(this,"started");this.callback=f,this.task=e,this.transferList=s,z(e)&&(this.transferList==null&&(this.transferList=[]),this.transferList=this.transferList.concat(e[y]),this.task=e[T]),this.filename=r,this.name=a,this.taskId=Te++,this.abortSignal=l,this.created=w.now(),this.started=0}releaseTask(){let e=this.task;return this.task=null,e}done(e,s){this.emitDestroy(),this.runInAsyncScope(this.callback,null,e,s),this.abortSignal&&this.abortListener&&("removeEventListener"in this.abortSignal&&this.abortListener?this.abortSignal.removeEventListener("abort",this.abortListener):this.abortSignal.off("abort",this.abortListener))}get[v](){return v in this.task?this.task[v]:null}},X=class{constructor(){t(this,"onreadyListeners",[])}markAsReady(){let e=this.onreadyListeners;R(e!==null),this.onreadyListeners=null;for(let s of e)s()}isReady(){return this.onreadyListeners===null}onReady(e){if(this.onreadyListeners===null){e();return}this.onreadyListeners.push(e)}},Z=class{constructor(e){t(this,"pendingItems",new Set);t(this,"readyItems",new Set);t(this,"maximumUsage");t(this,"onAvailableListeners");this.maximumUsage=e,this.onAvailableListeners=[]}add(e){this.pendingItems.add(e),e.onReady(()=>{this.pendingItems.has(e)&&(this.pendingItems.delete(e),this.readyItems.add(e),this.maybeAvailable(e))})}delete(e){this.pendingItems.delete(e),this.readyItems.delete(e)}findAvailable(){let e=this.maximumUsage,s=null;for(let r of this.readyItems){let a=r.currentUsage();if(a===0)return r;a<e&&(s=r,e=a)}return s}*[Symbol.iterator](){yield*this.pendingItems,yield*this.readyItems}get size(){return this.pendingItems.size+this.readyItems.size}maybeAvailable(e){if(e.currentUsage()<this.maximumUsage)for(let s of this.onAvailableListeners)s(e)}onAvailable(e){this.onAvailableListeners.push(e)}},I={ThreadTermination:()=>new Error("Terminating worker thread"),FilenameNotProvided:()=>new Error("filename must be provided to run() or in options object"),TaskQueueAtLimit:()=>new Error("Task queue is at limit"),NoTaskQueueAvailable:()=>new Error("No task queue available and all Workers are busy")},ee=class extends X{constructor(e,s,r){super();t(this,"worker");t(this,"taskInfos");t(this,"idleTimeout",null);t(this,"port");t(this,"sharedBuffer");t(this,"lastSeenResponseCount",0);t(this,"onMessage");this.worker=e,this.port=s,this.port.on("message",a=>this._handleResponse(a)),this.onMessage=r,this.taskInfos=new Map,this.sharedBuffer=new Int32Array(new SharedArrayBuffer(j*Int32Array.BYTES_PER_ELEMENT))}destroy(){this.worker.terminate(),this.port.close(),this.clearIdleTimeout();for(let e of this.taskInfos.values())e.done(I.ThreadTermination());this.taskInfos.clear()}clearIdleTimeout(){this.idleTimeout!==null&&(clearTimeout(this.idleTimeout),this.idleTimeout=null)}ref(){return this.port.ref(),this}unref(){return this.port.unref(),this}_handleResponse(e){this.onMessage(e),this.taskInfos.size===0&&this.unref()}postTask(e){R(!this.taskInfos.has(e.taskId));let s={task:e.releaseTask(),taskId:e.taskId,filename:e.filename,name:e.name};try{this.port.postMessage(s,e.transferList)}catch(r){e.done(r);return}e.workerInfo=this,this.taskInfos.set(e.taskId,e),this.ref(),this.clearIdleTimeout(),Atomics.add(this.sharedBuffer,Q,1),Atomics.notify(this.sharedBuffer,Q,1)}processPendingMessages(){let e=Atomics.load(this.sharedBuffer,F);if(e!==this.lastSeenResponseCount){this.lastSeenResponseCount=e;let s;for(;(s=ue(this.port))!==void 0;)this._handleResponse(s.message)}}isRunningAbortableTask(){if(this.taskInfos.size!==1)return!1;let[[,e]]=this.taskInfos;return e.abortSignal!==null}currentUsage(){return this.isRunningAbortableTask()?1/0:this.taskInfos.size}},se=class{constructor(e,s){t(this,"publicInterface");t(this,"workers");t(this,"options");t(this,"taskQueue");t(this,"skipQueue",[]);t(this,"completed",0);t(this,"start",w.now());t(this,"inProcessPendingMessages",!1);t(this,"startingUp",!1);t(this,"workerFailsDuringBootstrap",!1);this.publicInterface=e,this.taskQueue=s.taskQueue||new O;let r=s.filename?H(s.filename):null;this.options={...$,...s,filename:r,maxQueue:0},s.maxThreads!==void 0&&this.options.minThreads>=s.maxThreads&&(this.options.minThreads=s.maxThreads),s.minThreads!==void 0&&this.options.maxThreads<=s.minThreads&&(this.options.maxThreads=s.minThreads),s.maxQueue==="auto"?this.options.maxQueue=this.options.maxThreads**2:this.options.maxQueue=s.maxQueue??$.maxQueue,this.workers=new Z(this.options.concurrentTasksPerWorker),this.workers.onAvailable(a=>this._onWorkerAvailable(a)),this.startingUp=!0,this._ensureMinimumWorkers(),this.startingUp=!1}_ensureMinimumWorkers(){for(;this.workers.size<this.options.minThreads;)this._addNewWorker()}_addNewWorker(){let e=this,s=fe(q(import.meta.url)),r=new oe(ke(s,"./worker.js"),{env:this.options.env,argv:this.options.argv,execArgv:this.options.execArgv,resourceLimits:this.options.resourceLimits,workerData:this.options.workerData,trackUnmanagedFds:this.options.trackUnmanagedFds}),a=u=>{let{taskId:n,result:h}=u,b=i.taskInfos.get(n);if(i.taskInfos.delete(n),this.options.isolateWorkers||e.workers.maybeAvailable(i),b===void 0){let x=new Error(`Unexpected message from Worker: ${V(u)}`);e.publicInterface.emit("error",x)}else b.done(u.error,h);e._processPendingMessages()},{port1:f,port2:l}=new ae,i=new ee(r,f,a);this.startingUp&&i.markAsReady();let g={filename:this.options.filename,name:this.options.name,port:l,sharedBuffer:i.sharedBuffer,useAtomics:this.options.useAtomics};r.postMessage(g,[l]),r.on("message",u=>{if(u.ready===!0){i.currentUsage()===0&&i.unref(),i.isReady()||i.markAsReady();return}r.emit("error",new Error(`Unexpected message on Worker: ${V(u)}`))}),r.on("error",u=>{r.ref=()=>{};let n=[...i.taskInfos.values()];if(i.taskInfos.clear(),this._removeWorker(i),i.isReady()&&!this.workerFailsDuringBootstrap?this._ensureMinimumWorkers():this.workerFailsDuringBootstrap=!0,n.length>0)for(let h of n)h.done(u,null);else this.publicInterface.emit("error",u)}),r.unref(),f.on("close",()=>{r.ref()}),this.workers.add(i)}_processPendingMessages(){if(!(this.inProcessPendingMessages||!this.options.useAtomics)){this.inProcessPendingMessages=!0;try{for(let e of this.workers)e.processPendingMessages()}finally{this.inProcessPendingMessages=!1}}}_removeWorker(e){e.destroy(),this.workers.delete(e)}_onWorkerAvailable(e){for(;(this.taskQueue.size>0||this.skipQueue.length>0)&&e.currentUsage()<this.options.concurrentTasksPerWorker;){let s=this.skipQueue.shift()||this.taskQueue.shift();if(s.abortSignal&&e.taskInfos.size>0){this.skipQueue.push(s);break}let r=w.now();s.started=r,e.postTask(s),this._maybeDrain();return}e.taskInfos.size===0&&this.workers.size>this.options.minThreads&&(e.idleTimeout=setTimeout(()=>{R.strictEqual(e.taskInfos.size,0),this.workers.size>this.options.minThreads&&this._removeWorker(e)},this.options.idleTimeout).unref())}runTask(e,s){let{filename:r,name:a}=s,{transferList:f=[],signal:l=null}=s;if(r==null&&(r=this.options.filename),a==null&&(a=this.options.name),typeof r!="string")return Promise.reject(I.FilenameNotProvided());r=H(r);let i,g,u=new Promise((d,L)=>{i=d,g=L}),n=new K(e,f,r,a,(d,L)=>{this.completed++,d!==null?g(d):i(L),this.options.isolateWorkers&&n.workerInfo&&(n.workerInfo.taskInfos.delete(n.taskId),n.workerInfo.taskInfos.size||(this._removeWorker(n.workerInfo),this._ensureMinimumWorkers()))},l,this.publicInterface.asyncResource.asyncId());if(l!==null){if(l.aborted)return Promise.reject(new P);n.abortListener=()=>{g(new P),n.workerInfo!==null?(this._removeWorker(n.workerInfo),this._ensureMinimumWorkers()):this.taskQueue.remove(n)},be(l,n.abortListener)}if(this.taskQueue.size>0){let d=this.options.maxQueue+this.pendingCapacity();return this.taskQueue.size>=d?this.options.maxQueue===0?Promise.reject(I.NoTaskQueueAvailable()):Promise.reject(I.TaskQueueAtLimit()):(this.workers.size<this.options.maxThreads&&this._addNewWorker(),this.taskQueue.push(n),u)}let h=this.workers.findAvailable();h!==null&&h.currentUsage()>0&&l&&(h=null);let b=!1;if((h===null||h.currentUsage()>0)&&this.workers.size<this.options.maxThreads&&(this._addNewWorker(),b=!0),h===null)return this.options.maxQueue<=0&&!b?Promise.reject(I.NoTaskQueueAvailable()):(this.taskQueue.push(n),u);let x=w.now();return n.started=x,h.postTask(n),this._maybeDrain(),u}pendingCapacity(){return this.workers.pendingItems.size*this.options.concurrentTasksPerWorker}_maybeDrain(){this.taskQueue.size===0&&this.skipQueue.length===0&&this.publicInterface.emit("drain")}async destroy(){for(;this.skipQueue.length>0;)this.skipQueue.shift().done(new Error("Terminating worker thread"));for(;this.taskQueue.size>0;)this.taskQueue.shift().done(new Error("Terminating worker thread"));let e=[];for(;this.workers.size>0;){let[s]=this.workers;e.push(le(s.worker,"exit")),this._removeWorker(s)}await Promise.all(e)}},c,te=class extends N{constructor(e={}){super({...e,name:"Tinypool"});A(this,c,void 0);if(e.minThreads!==void 0&&e.maxThreads!==void 0&&e.minThreads>e.maxThreads)throw new RangeError("options.minThreads and options.maxThreads must not conflict");E(this,c,new se(this,e))}run(e,s=ye){let{transferList:r,filename:a,name:f,signal:l}=s;return m(this,c).runTask(e,{transferList:r,filename:a,name:f,signal:l})}destroy(){return m(this,c).destroy()}get options(){return m(this,c).options}get threads(){let e=[];for(let s of m(this,c).workers)e.push(s.worker);return e}get queueSize(){let e=m(this,c);return Math.max(e.taskQueue.size-e.pendingCapacity(),0)}get completed(){return m(this,c).completed}get duration(){return w.now()-m(this,c).start}static get isWorkerThread(){return process.__tinypool_state__?.isWorkerThread||!1}static get workerData(){return process.__tinypool_state__?.workerData||void 0}static get version(){let{version:e}=JSON.parse(ge(de(W,"../package.json"),"utf-8"));return e}static move(e){return e!=null&&typeof e=="object"&&typeof e!="function"&&(U(e)||(pe.isArrayBufferView(e)?e=new G(e):e=new Y(e)),C(e)),e}static get transferableSymbol(){return y}static get valueSymbol(){return T}static get queueOptionsSymbol(){return v}};c=new WeakMap;var $e=te;export{te as Tinypool,$e as default,z as isMovable,ve as isTaskQueue,U as isTransferable,j as kFieldCount,v as kQueueOptions,Q as kRequestCountField,F as kResponseCountField,y as kTransferable,T as kValue,C as markMovable};
