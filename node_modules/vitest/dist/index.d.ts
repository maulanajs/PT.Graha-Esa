import { Formatter } from 'picocolors/types';
import { ViteDevServer } from 'vite';
import { RawSourceMap } from 'source-map-js';
import { OptionsReceived } from 'pretty-format';
import { MessagePort } from 'worker_threads';
export { Spy, SpyFn } from 'tinyspy';
export { assert, default as chai, should } from 'chai';

declare const EXPECTED_COLOR: Formatter;
declare const RECEIVED_COLOR: Formatter;
declare const INVERTED_COLOR: Formatter;
declare const BOLD_WEIGHT: Formatter;
declare const DIM_COLOR: Formatter;
declare type MatcherHintOptions = {
    comment?: string;
    expectedColor?: Formatter;
    isDirectExpectCall?: boolean;
    isNot?: boolean;
    promise?: string;
    receivedColor?: Formatter;
    secondArgument?: string;
    secondArgumentColor?: Formatter;
};
declare function matcherHint(matcherName: string, received?: string, expected?: string, options?: MatcherHintOptions): string;
declare const stringify: (object: unknown, maxDepth?: number) => string;
declare const printReceived: (object: unknown) => string;
declare const printExpected: (value: unknown) => string;
declare type DiffOptions = {
    aAnnotation?: string;
    aColor?: Formatter;
    aIndicator?: string;
    bAnnotation?: string;
    bColor?: Formatter;
    bIndicator?: string;
    changeColor?: Formatter;
    changeLineTrailingSpaceColor?: Formatter;
    commonColor?: Formatter;
    commonIndicator?: string;
    commonLineTrailingSpaceColor?: Formatter;
    contextLines?: number;
    emptyFirstOrLastLinePlaceholder?: string;
    expand?: boolean;
    includeChangeCounts?: boolean;
    omitAnnotationLines?: boolean;
    patchColor?: Formatter;
    compareKeys?: any;
};
declare function diff(a: any, b: any, options?: DiffOptions): string;

declare const jestMatcherUtils_EXPECTED_COLOR: typeof EXPECTED_COLOR;
declare const jestMatcherUtils_RECEIVED_COLOR: typeof RECEIVED_COLOR;
declare const jestMatcherUtils_INVERTED_COLOR: typeof INVERTED_COLOR;
declare const jestMatcherUtils_BOLD_WEIGHT: typeof BOLD_WEIGHT;
declare const jestMatcherUtils_DIM_COLOR: typeof DIM_COLOR;
type jestMatcherUtils_MatcherHintOptions = MatcherHintOptions;
declare const jestMatcherUtils_matcherHint: typeof matcherHint;
declare const jestMatcherUtils_stringify: typeof stringify;
declare const jestMatcherUtils_printReceived: typeof printReceived;
declare const jestMatcherUtils_printExpected: typeof printExpected;
type jestMatcherUtils_DiffOptions = DiffOptions;
declare const jestMatcherUtils_diff: typeof diff;
declare namespace jestMatcherUtils {
  export {
    jestMatcherUtils_EXPECTED_COLOR as EXPECTED_COLOR,
    jestMatcherUtils_RECEIVED_COLOR as RECEIVED_COLOR,
    jestMatcherUtils_INVERTED_COLOR as INVERTED_COLOR,
    jestMatcherUtils_BOLD_WEIGHT as BOLD_WEIGHT,
    jestMatcherUtils_DIM_COLOR as DIM_COLOR,
    jestMatcherUtils_MatcherHintOptions as MatcherHintOptions,
    jestMatcherUtils_matcherHint as matcherHint,
    jestMatcherUtils_stringify as stringify,
    jestMatcherUtils_printReceived as printReceived,
    jestMatcherUtils_printExpected as printExpected,
    jestMatcherUtils_DiffOptions as DiffOptions,
    jestMatcherUtils_diff as diff,
  };
}

declare type Tester = (a: any, b: any) => boolean | undefined;
declare type MatcherState = {
    assertionCalls: number;
    currentTestName?: string;
    dontThrow?: () => void;
    error?: Error;
    equals: (a: unknown, b: unknown, customTesters?: Array<Tester>, strictCheck?: boolean) => boolean;
    expand?: boolean;
    expectedAssertionsNumber?: number | null;
    expectedAssertionsNumberError?: Error;
    isExpectingAssertions?: boolean;
    isExpectingAssertionsError?: Error;
    isNot: boolean;
    promise: string;
    suppressedErrors: Array<Error>;
    testPath?: string;
    utils: typeof jestMatcherUtils & {
        iterableEquality: Tester;
        subsetEquality: Tester;
    };
};
declare type SyncExpectationResult = {
    pass: boolean;
    message: () => string;
};
declare type AsyncExpectationResult = Promise<SyncExpectationResult>;
declare type ExpectationResult = SyncExpectationResult | AsyncExpectationResult;
declare type RawMatcherFn<T extends MatcherState = MatcherState> = {
    (this: T, received: any, expected: any, options?: any): ExpectationResult;
};
declare type MatchersObject<T extends MatcherState = MatcherState> = {
    [id: string]: RawMatcherFn<T>;
};

interface AsymmetricMatcherInterface {
    asymmetricMatch(other: unknown): boolean;
    toString(): string;
    getExpectedType?(): string;
    toAsymmetricMatcher?(): string;
}
declare abstract class AsymmetricMatcher<T, State extends MatcherState = MatcherState> implements AsymmetricMatcherInterface {
    protected sample: T;
    protected inverse: boolean;
    $$typeof: symbol;
    constructor(sample: T, inverse?: boolean);
    protected getMatcherContext(): State;
    abstract asymmetricMatch(other: unknown): boolean;
    abstract toString(): string;
    getExpectedType?(): string;
    toAsymmetricMatcher?(): string;
}
declare class Anything extends AsymmetricMatcher<void> {
    asymmetricMatch(other: unknown): boolean;
    toString(): string;
    toAsymmetricMatcher(): string;
}
declare class ObjectContaining extends AsymmetricMatcher<Record<string, unknown>> {
    constructor(sample: Record<string, unknown>, inverse?: boolean);
    getPrototype(obj: object): any;
    hasProperty(obj: object | null, property: string): boolean;
    asymmetricMatch(other: any): boolean;
    toString(): string;
    getExpectedType(): string;
}
declare class ArrayContaining extends AsymmetricMatcher<Array<unknown>> {
    constructor(sample: Array<unknown>, inverse?: boolean);
    asymmetricMatch(other: Array<unknown>): boolean;
    toString(): string;
    getExpectedType(): string;
}
declare class Any extends AsymmetricMatcher<any> {
    constructor(sample: unknown);
    fnNameFor(func: Function): string;
    asymmetricMatch(other: unknown): boolean;
    toString(): string;
    getExpectedType(): string;
    toAsymmetricMatcher(): string;
}
declare class StringMatching extends AsymmetricMatcher<RegExp> {
    constructor(sample: string | RegExp, inverse?: boolean);
    asymmetricMatch(other: string): boolean;
    toString(): string;
    getExpectedType(): string;
}

declare class SnapshotManager {
    config: ResolvedConfig;
    summary: SnapshotSummary;
    constructor(config: ResolvedConfig);
    clear(): void;
    add(result: SnapshotResult): void;
}

declare type RunWithFiles = (files: string[], invalidates?: string[]) => Promise<void>;
interface WorkerPool {
    runTests: RunWithFiles;
    collectTests: RunWithFiles;
    close: () => Promise<void>;
}

declare class StateManager {
    filesMap: Map<string, File>;
    idMap: Map<string, Task>;
    taskFileMap: WeakMap<Task, File>;
    getFiles(keys?: string[]): File[];
    collectFiles(files?: File[]): void;
    updateId(task: Task): void;
    updateTasks(packs: TaskResultPack[]): void;
}

declare class Vitest {
    config: ResolvedConfig;
    server: ViteDevServer;
    state: StateManager;
    snapshot: SnapshotManager;
    reporters: Reporter[];
    console: Console;
    pool: WorkerPool | undefined;
    outputStream: NodeJS.WriteStream & {
        fd: 1;
    };
    errorStream: NodeJS.WriteStream & {
        fd: 2;
    };
    invalidates: Set<string>;
    changedTests: Set<string>;
    visitedFilesMap: Map<string, RawSourceMap>;
    runningPromise?: Promise<void>;
    isFirstRun: boolean;
    restartsCount: number;
    private _onRestartListeners;
    constructor();
    setServer(options: UserConfig, server: ViteDevServer): Promise<void>;
    start(filters?: string[]): Promise<void>;
    runFiles(files: string[]): Promise<void>;
    log(...args: any[]): void;
    error(...args: any[]): void;
    private _rerunTimer;
    private scheduleRerun;
    private unregisterWatcher;
    private registerWatcher;
    private handleFileChanged;
    close(): Promise<void>;
    report<T extends keyof Reporter>(name: T, ...args: ArgumentsType<Reporter[T]>): Promise<void>;
    globTestFiles(filters?: string[]): Promise<string[]>;
    isTargetFile(id: string): boolean;
    onServerRestarted(fn: () => void): void;
}

declare abstract class BaseReporter implements Reporter {
    start: number;
    end: number;
    watchFilters?: string[];
    isTTY: boolean;
    ctx: Vitest;
    onInit(ctx: Vitest): void;
    relative(path: string): string;
    onFinished(files?: File[]): Promise<void>;
    onTaskUpdate(packs: TaskResultPack[]): void;
    isFirstWatchRun: boolean;
    onWatcherStart(): Promise<void>;
    onWatcherRerun(files: string[], trigger?: string): Promise<void>;
    onUserConsoleLog(log: UserConsoleLog): void;
    onServerRestart(): void;
    reportSummary(files: File[]): Promise<void>;
    private printTaskErrors;
}

interface ListRendererOptions {
    renderSucceed?: boolean;
    outputStream: NodeJS.WritableStream;
}
declare const createListRenderer: (_tasks: Task[], options: ListRendererOptions) => {
    start(): any;
    update(_tasks: Task[]): any;
    stop(): Promise<any>;
    clear(): void;
};

declare class DefaultReporter extends BaseReporter {
    renderer?: ReturnType<typeof createListRenderer>;
    rendererOptions: ListRendererOptions;
    onCollected(): void;
    onFinished(files?: File[]): Promise<void>;
    onWatcherStart(): Promise<void>;
    stopListRender(): Promise<void>;
    onWatcherRerun(files: string[], trigger?: string): Promise<void>;
    onUserConsoleLog(log: UserConsoleLog): void;
}

declare class DotReporter extends BaseReporter {
    renderer?: ReturnType<typeof createListRenderer>;
    onCollected(): void;
    onFinished(files?: File[]): Promise<void>;
    onWatcherStart(): Promise<void>;
    stopListRender(): Promise<void>;
    onWatcherRerun(files: string[], trigger?: string): Promise<void>;
    onUserConsoleLog(log: UserConsoleLog): void;
}

declare class VerboseReporter extends DefaultReporter {
    constructor();
}

declare const ReportersMap: {
    default: typeof DefaultReporter;
    verbose: typeof VerboseReporter;
    dot: typeof DotReporter;
};
declare type BuiltinReporters = keyof typeof ReportersMap;

declare type CoverageReporter = 'clover' | 'cobertura' | 'html-spa' | 'html' | 'json-summary' | 'json' | 'lcov' | 'lcovonly' | 'none' | 'teamcity' | 'text-lcov' | 'text-summary' | 'text';
interface C8Options {
    /**
     * Enable coverage, pass `--coverage` to enable
     *
     * @default false
     */
    enabled?: boolean;
    /**
     * Directory to write coverage report to
     */
    reportsDirectory?: string;
    /**
     * Clean coverage before running tests
     *
     * @default true
     */
    clean?: boolean;
    /**
     * Clean coverage report on watch rerun
     *
     * @default false
     */
    cleanOnRerun?: boolean;
    /**
     * Allow files from outside of your cwd.
     *
     * @default false
     */
    allowExternal?: any;
    /**
     * Reporters
     *
     * @default 'text'
     */
    reporter?: Arrayable<CoverageReporter>;
    /**
     * Exclude coverage under /node_modules/
     *
     * @default true
     */
    excludeNodeModules?: boolean;
    exclude?: string[];
    include?: string[];
    skipFull?: boolean;
}
interface ResolvedC8Options extends Required<C8Options> {
    tempDirectory: string;
}

declare type Awaitable<T> = T | PromiseLike<T>;
declare type Nullable<T> = T | null | undefined;
declare type Arrayable<T> = T | Array<T>;
declare type ArgumentsType<T> = T extends (...args: infer U) => any ? U : never;
interface ModuleCache {
    promise?: Promise<any>;
    exports?: any;
    code?: string;
}
interface EnvironmentReturn {
    teardown: (global: any) => Awaitable<void>;
}
interface Environment {
    name: string;
    setup(global: any): Awaitable<EnvironmentReturn>;
}
interface UserConsoleLog {
    content: string;
    type: 'stdout' | 'stderr';
    taskId?: string;
}
interface Position {
    line: number;
    column: number;
}
interface ParsedStack {
    method: string;
    file: string;
    line: number;
    column: number;
}

declare type ChainableFunction<T extends string, Args extends any[], R = any> = {
    (...args: Args): R;
} & {
    [x in T]: ChainableFunction<T, Args, R>;
};

declare type RunMode = 'run' | 'skip' | 'only' | 'todo';
declare type TaskState = RunMode | 'pass' | 'fail';
declare type ComputeMode = 'serial' | 'concurrent';
interface TaskBase {
    id: string;
    name: string;
    mode: RunMode;
    computeMode: ComputeMode;
    suite?: Suite;
    file?: File;
    result?: TaskResult;
}
interface TaskResult {
    state: TaskState;
    start: number;
    end?: number;
    error?: unknown;
}
declare type TaskResultPack = [id: string, result: TaskResult | undefined];
interface Suite extends TaskBase {
    type: 'suite';
    tasks: Task[];
}
interface File extends Suite {
    filepath: string;
}
interface Test extends TaskBase {
    type: 'test';
    suite: Suite;
    result?: TaskResult;
    fails?: boolean;
}
declare type Task = Test | Suite | File;
declare type DoneCallback = (error?: any) => void;
declare type TestFunction = (done: DoneCallback) => Awaitable<void>;
declare type TestCollector = ChainableFunction<'concurrent' | 'only' | 'skip' | 'todo' | 'fails', [
    name: string,
    fn?: TestFunction,
    timeout?: number
], void>;
declare type HookListener<T extends any[]> = (...args: T) => Awaitable<void>;
interface SuiteHooks {
    beforeAll: HookListener<[Suite]>[];
    afterAll: HookListener<[Suite]>[];
    beforeEach: HookListener<[Test, Suite]>[];
    afterEach: HookListener<[Test, Suite]>[];
}
interface SuiteCollector {
    readonly name: string;
    readonly mode: RunMode;
    type: 'collector';
    test: TestCollector;
    tasks: (Suite | Test | SuiteCollector)[];
    collect: (file?: File) => Promise<Suite>;
    clear: () => void;
    on: <T extends keyof SuiteHooks>(name: T, ...fn: SuiteHooks[T]) => void;
}
declare type TestFactory = (test: (name: string, fn: TestFunction) => void) => Awaitable<void>;
interface RuntimeContext {
    tasks: (SuiteCollector | Test)[];
    currentSuite: SuiteCollector | null;
}

interface Reporter {
    onInit?(ctx: Vitest): void;
    onCollected?: (files?: File[]) => Awaitable<void>;
    onFinished?: (files?: File[]) => Awaitable<void>;
    onTaskUpdate?: (packs: TaskResultPack[]) => Awaitable<void>;
    onWatcherStart?: () => Awaitable<void>;
    onWatcherRerun?: (files: string[], trigger?: string) => Awaitable<void>;
    onServerRestart?: () => Awaitable<void>;
    onUserConsoleLog?: (log: UserConsoleLog) => Awaitable<void>;
}

declare type SnapshotData = Record<string, string>;
declare type SnapshotUpdateState = 'all' | 'new' | 'none';
declare type SnapshotStateOptions = {
    updateSnapshot: SnapshotUpdateState;
    expand?: boolean;
    snapshotFormat?: OptionsReceived;
};
declare type SnapshotMatchOptions = {
    testName: string;
    received: unknown;
    key?: string;
    inlineSnapshot?: string;
    isInline: boolean;
    error?: Error;
};
interface SnapshotResult {
    filepath: string;
    added: number;
    fileDeleted: boolean;
    matched: number;
    unchecked: number;
    uncheckedKeys: Array<string>;
    unmatched: number;
    updated: number;
}
interface UncheckedSnapshot {
    filePath: string;
    keys: Array<string>;
}
interface SnapshotSummary {
    added: number;
    didUpdate: boolean;
    failure: boolean;
    filesAdded: number;
    filesRemoved: number;
    filesRemovedList: Array<string>;
    filesUnmatched: number;
    filesUpdated: number;
    matched: number;
    total: number;
    unchecked: number;
    uncheckedKeysByFile: Array<UncheckedSnapshot>;
    unmatched: number;
    updated: number;
}

declare type BuiltinEnvironment = 'node' | 'jsdom' | 'happy-dom';
interface InlineConfig {
    /**
     * Include globs for test files
     *
     * @default ['**\/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}']
     */
    include?: string[];
    /**
     * Exclude globs for test files
     * @default ['node_modules', 'dist', '.idea', '.git', '.cache']
     */
    exclude?: string[];
    /**
     * Handling for dependencies inlining or externalizing
     */
    deps?: {
        /**
         * Externalize means that Vite will bypass the package to native Node.
         *
         * Externalized dependencies will not be applied Vite's transformers and resolvers.
         * And does not support HMR on reload.
         *
         * Typically, packages under `node_modules` are externalized.
         */
        external?: (string | RegExp)[];
        /**
         * Vite will process inlined modules.
         *
         * This could be helpful to handle packages that ship `.js` in ESM format (that Node can't handle).
         */
        inline?: (string | RegExp)[];
    };
    /**
     * Register apis globally
     *
     * @default false
     */
    global?: boolean;
    /**
     * Running environment
     *
     * Supports 'node', 'jsdom', 'happy-dom'
     *
     * @default 'node'
     */
    environment?: BuiltinEnvironment;
    /**
     * Update snapshot files
     *
     * @default false
     */
    update?: boolean;
    /**
     * Watch mode
     *
     * @default false
     */
    watch?: boolean;
    /**
     * Project root
     */
    root?: string;
    /**
     * Custom reporter for output
     */
    reporters?: Arrayable<BuiltinReporters | Reporter>;
    /**
     * Enable multi-threading
     *
     * @default true
     */
    threads?: boolean;
    /**
     * Maximum number of threads
     *
     * @default available CPUs
     */
    maxThreads?: number;
    /**
     * Minimum number of threads
     *
     * @default available CPUs
     */
    minThreads?: number;
    interpretDefault?: boolean;
    /**
     * Default timeout of a test in milliseconds
     *
     * @default 5000
     */
    testTimeout?: number;
    /**
     * Default timeout of a hook in milliseconds
     *
     * @default 5000
     */
    hookTimeout?: number;
    /**
     * Silent mode
     *
     * @default false
     */
    silent?: boolean;
    /**
     * Path to setup files
     */
    setupFiles?: string | string[];
    /**
     * Pattern of file paths to be ignore from triggering watch rerun
     *
     * @default ['**\/node_modules\/**', '**\/dist/**']
     */
    watchIgnore?: (string | RegExp)[];
    /**
     * Isolate environment for each test file
     *
     * @default true
     */
    isolate?: boolean;
    /**
     * Coverage options
     */
    coverage?: C8Options;
    /**
     * Open Vitest UI
     * @internal WIP
     */
    open?: boolean;
    /**
     * run test names with the specified pattern
     */
    testNamePattern?: string | RegExp;
    /**
     * Listen to port and serve API
     *
     * When set to true, the default port is 55555
     *
     * @internal WIP
     * @default false
     */
    api?: boolean | number;
    /**
     * Will call `.mockClear()` on all spies before each test
     * @default false
     */
    clearMocks?: boolean;
    /**
     * Will call `.mockReset()` on all spies before each test
     * @default false
     */
    mockReset?: boolean;
    /**
     * Will call `.mockRestore()` on all spies before each test
     * @default false
     */
    restoreMocks?: boolean;
}
interface UserConfig extends InlineConfig {
    /**
     * Path to the config file.
     *
     * Default resolving to one of:
     * - `vitest.config.js`
     * - `vitest.config.ts`
     * - `vite.config.js`
     * - `vite.config.ts`
     */
    config?: string | undefined;
    /**
     * Use happy-dom
     */
    dom?: boolean;
    /**
     * Do not watch
     */
    run?: boolean;
    /**
     * Pass with no tests
     */
    passWithNoTests?: boolean;
}
interface ResolvedConfig extends Omit<Required<UserConfig>, 'config' | 'filters' | 'coverage' | 'testNamePattern'> {
    config?: string;
    filters?: string[];
    testNamePattern?: RegExp;
    depsInline: (string | RegExp)[];
    depsExternal: (string | RegExp)[];
    coverage: ResolvedC8Options;
    snapshotOptions: SnapshotStateOptions;
}

interface WorkerContext {
    port: MessagePort;
    config: ResolvedConfig;
    files: string[];
    invalidates?: string[];
}
interface WorkerRPC {
    fetch: (id: string) => Promise<string | undefined>;
    getSourceMap: (id: string, force?: boolean) => Promise<RawSourceMap | undefined>;
    onWorkerExit: (code?: number) => void;
    onUserLog: (log: UserConsoleLog) => void;
    onCollected: (files: File[]) => void;
    onTaskUpdate: (pack: TaskResultPack[]) => void;
    snapshotSaved: (snapshot: SnapshotResult) => void;
}

declare const suite: ChainableFunction<"concurrent" | "skip" | "only" | "todo", [name: string, factory?: TestFactory | undefined], SuiteCollector>;
declare const test: TestCollector;
declare const describe: ChainableFunction<"concurrent" | "skip" | "only" | "todo", [name: string, factory?: TestFactory | undefined], SuiteCollector>;
declare const it: TestCollector;

declare const beforeAll: (fn: SuiteHooks['beforeAll'][0], timeout?: number | undefined) => void;
declare const afterAll: (fn: SuiteHooks['afterAll'][0], timeout?: number | undefined) => void;
declare const beforeEach: (fn: SuiteHooks['beforeEach'][0], timeout?: number | undefined) => void;
declare const afterEach: (fn: SuiteHooks['afterEach'][0], timeout?: number | undefined) => void;

declare const expect: Chai.ExpectStatic;

interface MockResultReturn<T> {
    type: 'return';
    value: T;
}
interface MockResultIncomplete {
    type: 'incomplete';
    value: undefined;
}
interface MockResultThrow {
    type: 'throw';
    value: any;
}
declare type MockResult<T> = MockResultReturn<T> | MockResultThrow | MockResultIncomplete;
interface JestMockCompatContext<T, Y> {
    calls: Y[];
    instances: T[];
    invocationCallOrder: number[];
    results: MockResult<T>[];
}
interface JestMockCompat<TArgs extends any[] = any[], TReturns = any> {
    getMockName(): string;
    mockName(n: string): this;
    mock: JestMockCompatContext<TArgs, TReturns>;
    mockClear(): this;
    mockReset(): this;
    mockRestore(): void;
    getMockImplementation(): ((...args: TArgs) => TReturns) | undefined;
    mockImplementation(fn: ((...args: TArgs) => TReturns) | (() => Promise<TReturns>)): this;
    mockImplementationOnce(fn: ((...args: TArgs) => TReturns) | (() => Promise<TReturns>)): this;
    mockReturnThis(): this;
    mockReturnValue(obj: TReturns): this;
    mockReturnValueOnce(obj: TReturns): this;
    mockResolvedValue(obj: Awaited<TReturns>): this;
    mockResolvedValueOnce(obj: Awaited<TReturns>): this;
    mockRejectedValue(obj: any): this;
    mockRejectedValueOnce(obj: any): this;
}
interface JestMockCompatFn<TArgs extends any[] = any, TReturns = any> extends JestMockCompat<TArgs, TReturns> {
    (...args: TArgs): TReturns;
}
declare type MockableFunction = (...args: Array<any>) => any;
declare type MethodKeysOf<T> = {
    [K in keyof T]: T[K] extends MockableFunction ? K : never;
}[keyof T];
declare type PropertyKeysOf<T> = {
    [K in keyof T]: T[K] extends MockableFunction ? never : K;
}[keyof T];
declare type ArgumentsOf<T> = T extends (...args: infer A) => any ? A : never;
declare type ConstructorArgumentsOf<T> = T extends new (...args: infer A) => any ? A : never;
declare type MaybeMockedConstructor<T> = T extends new (...args: Array<any>) => infer R ? JestMockCompatFn<ConstructorArgumentsOf<T>, R> : T;
declare type MockedFunction<T extends MockableFunction> = MockWithArgs<T> & {
    [K in keyof T]: T[K];
};
declare type MockedFunctionDeep<T extends MockableFunction> = MockWithArgs<T> & MockedObjectDeep<T>;
declare type MockedObject<T> = MaybeMockedConstructor<T> & {
    [K in MethodKeysOf<T>]: T[K] extends MockableFunction ? MockedFunction<T[K]> : T[K];
} & {
    [K in PropertyKeysOf<T>]: T[K];
};
declare type MockedObjectDeep<T> = MaybeMockedConstructor<T> & {
    [K in MethodKeysOf<T>]: T[K] extends MockableFunction ? MockedFunctionDeep<T[K]> : T[K];
} & {
    [K in PropertyKeysOf<T>]: MaybeMockedDeep<T[K]>;
};
declare type MaybeMockedDeep<T> = T extends MockableFunction ? MockedFunctionDeep<T> : T extends object ? MockedObjectDeep<T> : T;
declare type MaybeMocked<T> = T extends MockableFunction ? MockedFunction<T> : T extends object ? MockedObject<T> : T;
interface MockWithArgs<T extends MockableFunction> extends JestMockCompatFn<ArgumentsOf<T>, ReturnType<T>> {
    new (...args: ConstructorArgumentsOf<T>): T;
    (...args: ArgumentsOf<T>): ReturnType<T>;
}
declare const spies: Set<JestMockCompat<any[], any>>;
declare function spyOn<T, K extends keyof T>(obj: T, method: K, accessType?: 'get' | 'set'): T[K] extends (...args: infer TArgs) => infer TReturnValue ? JestMockCompat<TArgs, TReturnValue> : JestMockCompat;
declare type Awaited<T> = T extends Promise<infer R> ? R : never;
declare function fn<TArgs extends any[] = any[], R = any>(): JestMockCompatFn<TArgs, R>;
declare function fn<TArgs extends any[] = any[], R = any>(implementation: (...args: TArgs) => R): JestMockCompatFn<TArgs, R>;

declare class VitestUtils {
    private _timers;
    private _mockedDate;
    constructor();
    useFakeTimers(): void;
    useRealTimers(): void;
    runOnlyPendingTimers(): void | Promise<void>;
    runAllTimers(): void | Promise<void>;
    advanceTimersByTime(ms: number): void | Promise<void>;
    advanceTimersToNextTimer(): void | Promise<void>;
    getTimerCount(): number;
    mockCurrentDate(date: string | number | Date): void;
    restoreCurrentDate(): void;
    getMockedDate(): string | number | Date | null;
    spyOn: typeof spyOn;
    fn: typeof fn;
    /**
     * Makes all `imports` to passed module to be mocked.
     * - If there is a factory, will return it's result. The call to `vi.mock` is hoisted to the top of the file,
     * so you don't have access to variables declared in the global file scope, if you didn't put them before imports!
     * - If `__mocks__` folder with file of the same name exist, all imports will
     * return it.
     * - If there is no `__mocks__` folder or a file with the same name inside, will call original
     * module and mock it.
     * @param path Path to the module. Can be aliased, if your config suppors it
     * @param factory Factory for the mocked module. Has the highest priority.
     */
    mock(path: string, factory?: () => any): void;
    /**
     * Removes module from mocked registry. All subsequent calls to import will
     * return original module even if it was mocked.
     * @param path Path to the module. Can be aliased, if your config suppors it
     */
    unmock(path: string): void;
    /**
     * Imports module, bypassing all checks if it should be mocked.
     * Can be useful if you want to mock module partially.
     * @example
     * vi.mock('./example', async () => {
     *  const axios = await vi.importActual('./example')
     *
     *  return { ...axios, get: vi.fn() }
     * })
     * @param path Path to the module. Can be aliased, if your config suppors it
     * @returns Actual module without spies
     */
    importActual<T>(path: string): Promise<T>;
    /**
     * Imports a module with all of its properties and nested properties mocked.
     * For the rules applied, see docs.
     * @param path Path to the module. Can be aliased, if your config suppors it
     * @returns Fully mocked module
     */
    importMock<T>(path: string): Promise<MaybeMockedDeep<T>>;
    /**
     * Type helpers for TypeScript. In reality just returns the object that was passed.
     * @example
     * import example from './example'
     * vi.mock('./example')
     *
     * test('1+1 equals 2' async () => {
     *  vi.mocked(example.calc).mockRestore()
     *
     *  const res = example.calc(1, '+', 1)
     *
     *  expect(res).toBe(2)
     * })
     * @param item Anything that can be mocked
     * @param deep If the object is deeply mocked
     */
    mocked<T>(item: T, deep?: false): MaybeMocked<T>;
    mocked<T>(item: T, deep: true): MaybeMockedDeep<T>;
    isMockFunction(fn: any): any;
    clearAllMocks(): this;
    resetAllMocks(): this;
    restoreAllMocks(): this;
}
declare const vitest: VitestUtils;
declare const vi: VitestUtils;

interface WebSocketHandlers {
    getFiles(): File[];
    getConfig(): ResolvedConfig;
    getSourceCode(id: string): Promise<string>;
    rerun(files: string[]): Promise<void>;
}
interface WebSocketEvents extends Pick<Reporter, 'onCollected' | 'onTaskUpdate'> {
}

declare type VitestInlineConfig = InlineConfig;

declare module 'vite' {
    interface UserConfig {
        /**
         * Options for Vitest
         */
        test?: VitestInlineConfig;
    }
}
declare global {
    namespace Chai {
        interface ExpectStatic {
            extend(expects: MatchersObject): void;
            stringContaining(expected: string): void;
            anything(): Anything;
            objectContaining(expected: any): ObjectContaining;
            any(constructor: unknown): Any;
            arrayContaining(expected: any): ArrayContaining;
            stringMatching(expected: RegExp): StringMatching;
            assertions(expected: number): void;
        }
        interface Assertion {
            chaiEqual(expected: any): void;
            toMatchSnapshot(message?: string): Assertion;
            toMatchInlineSnapshot(snapshot?: string, message?: string): Assertion;
            matchSnapshot(message?: string): Assertion;
            toEqual(expected: any): void;
            toStrictEqual(expected: any): void;
            toBe(expected: any): void;
            toMatch(expected: string | RegExp): void;
            toMatchObject(expected: any): void;
            toContain(item: any): void;
            toContainEqual(item: any): void;
            toBeTruthy(): void;
            toBeFalsy(): void;
            toBeGreaterThan(num: number): void;
            toBeGreaterThanOrEqual(num: number): void;
            toBeLessThan(num: number): void;
            toBeLessThanOrEqual(num: number): void;
            toBeNaN(): void;
            toBeUndefined(): void;
            toBeNull(): void;
            toBeDefined(): void;
            toBeInstanceOf(c: any): void;
            toBeCalledTimes(n: number): void;
            toHaveLength(l: number): void;
            toHaveProperty(p: string, value?: any): void;
            toBeCloseTo(number: number, numDigits?: number): void;
            toHaveBeenCalledTimes(n: number): void;
            toHaveBeenCalledOnce(): void;
            toHaveBeenCalled(): void;
            toBeCalled(): void;
            toHaveBeenCalledWith(...args: any[]): void;
            toBeCalledWith(...args: any[]): void;
            toHaveBeenNthCalledWith(n: number, ...args: any[]): void;
            nthCalledWith(n: number, ...args: any[]): void;
            toHaveBeenLastCalledWith(...args: any[]): void;
            lastCalledWith(...args: any[]): void;
            toThrow(expected?: string | RegExp): void;
            toThrowError(expected?: string | RegExp): void;
            toReturn(): void;
            toHaveReturned(): void;
            toReturnTimes(times: number): void;
            toHaveReturnedTimes(times: number): void;
            toReturnWith(value: any): void;
            toHaveReturnedWith(value: any): void;
            toHaveLastReturnedWith(value: any): void;
            lastReturnedWith(value: any): void;
            toHaveNthReturnedWith(nthCall: number, value: any): void;
            nthReturnedWith(nthCall: number, value: any): void;
        }
    }
}

export { ArgumentsOf, ArgumentsType, Arrayable, Awaitable, BuiltinEnvironment, ComputeMode, ConstructorArgumentsOf, DoneCallback, Environment, EnvironmentReturn, File, HookListener, InlineConfig, JestMockCompat, JestMockCompatContext, JestMockCompatFn, MaybeMocked, MaybeMockedConstructor, MaybeMockedDeep, MethodKeysOf, MockWithArgs, MockableFunction, MockedFunction, MockedFunctionDeep, MockedObject, MockedObjectDeep, ModuleCache, Nullable, ParsedStack, Position, PropertyKeysOf, Reporter, ResolvedConfig, RunMode, RuntimeContext, SnapshotData, SnapshotMatchOptions, SnapshotResult, SnapshotStateOptions, SnapshotSummary, SnapshotUpdateState, Suite, SuiteCollector, SuiteHooks, Task, TaskBase, TaskResult, TaskResultPack, TaskState, Test, TestCollector, TestFactory, TestFunction, UncheckedSnapshot, UserConfig, UserConsoleLog, WebSocketEvents, WebSocketHandlers, WorkerContext, WorkerRPC, afterAll, afterEach, beforeAll, beforeEach, describe, expect, fn, it, spies, spyOn, suite, test, vi, vitest };
