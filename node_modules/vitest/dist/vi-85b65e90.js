import { n as noop, i as isObject } from './index-80671389.js';
import { c as commonjsGlobal, g as getDefaultExportFromCjs } from './_commonjsHelpers-c9e3b764.js';
import { a as spyOn, f as fn, s as spies } from './jest-mock-4a754991.js';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function createChainable(keys, fn) {
  function create(obj) {
    const chain2 = function(...args) {
      return fn.apply(obj, args);
    };
    for (const key of keys) {
      Object.defineProperty(chain2, key, {
        get() {
          return create(__spreadProps(__spreadValues({}, obj), { [key]: true }));
        }
      });
    }
    return chain2;
  }
  const chain = create({});
  chain.fn = fn;
  return chain;
}

const context = {
  tasks: [],
  currentSuite: null
};
function collectTask(task) {
  var _a;
  (_a = context.currentSuite) == null ? void 0 : _a.tasks.push(task);
}
async function runWithSuite(suite, fn) {
  const prev = context.currentSuite;
  context.currentSuite = suite;
  await fn();
  context.currentSuite = prev;
}
function getDefaultTestTimeout() {
  return process.__vitest_worker__.config.testTimeout;
}
function getDefaultHookTimeout() {
  return process.__vitest_worker__.config.hookTimeout;
}
function withTimeout(fn, _timeout) {
  const timeout = _timeout ?? getDefaultTestTimeout();
  if (timeout <= 0 || timeout === Infinity)
    return fn;
  return (...args) => {
    return Promise.race([fn(...args), new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        clearTimeout(timer);
        reject(new Error(`Test timed out in ${timeout}ms.`));
      }, timeout);
      timer.unref();
    })]);
  };
}
function ensureAsyncTest(fn) {
  if (!fn.length)
    return fn;
  return () => new Promise((resolve, reject) => {
    const done = (...args) => args[0] ? reject(args[0]) : resolve();
    fn(done);
  });
}
function normalizeTest(fn, timeout) {
  return withTimeout(ensureAsyncTest(fn), timeout);
}

const fnMap = /* @__PURE__ */ new WeakMap();
const hooksMap = /* @__PURE__ */ new WeakMap();
function setFn(key, fn) {
  fnMap.set(key, fn);
}
function getFn(key) {
  return fnMap.get(key);
}
function setHooks(key, hooks) {
  hooksMap.set(key, hooks);
}
function getHooks(key) {
  return hooksMap.get(key);
}

const suite = createSuite();
const test = createChainable(["concurrent", "skip", "only", "todo", "fails"], function(name, fn, timeout) {
  getCurrentSuite().test.fn.call(this, name, fn, timeout);
});
const describe = suite;
const it = test;
const defaultSuite = suite("");
function clearContext() {
  context.tasks.length = 0;
  defaultSuite.clear();
  context.currentSuite = defaultSuite;
}
function getCurrentSuite() {
  return context.currentSuite || defaultSuite;
}
function createSuiteHooks() {
  return {
    beforeAll: [],
    afterAll: [],
    beforeEach: [],
    afterEach: []
  };
}
function createSuiteCollector(name, factory = () => {
}, mode, suiteComputeMode) {
  const tasks = [];
  const factoryQueue = [];
  let suite2;
  initSuite();
  const test2 = createChainable(["concurrent", "skip", "only", "todo", "fails"], function(name2, fn, timeout) {
    const mode2 = this.only ? "only" : this.skip ? "skip" : this.todo ? "todo" : "run";
    const computeMode = this.concurrent ? "concurrent" : void 0;
    const test3 = {
      id: "",
      type: "test",
      name: name2,
      mode: mode2,
      computeMode: computeMode ?? (suiteComputeMode ?? "serial"),
      suite: void 0,
      fails: this.fails
    };
    setFn(test3, normalizeTest(fn || noop, timeout));
    tasks.push(test3);
  });
  const collector = {
    type: "collector",
    name,
    mode,
    test: test2,
    tasks,
    collect,
    clear,
    on: addHook
  };
  function addHook(name2, ...fn) {
    getHooks(suite2)[name2].push(...fn);
  }
  function initSuite() {
    suite2 = {
      id: "",
      type: "suite",
      computeMode: "serial",
      name,
      mode,
      tasks: []
    };
    setHooks(suite2, createSuiteHooks());
  }
  function clear() {
    tasks.length = 0;
    factoryQueue.length = 0;
    initSuite();
  }
  async function collect(file) {
    factoryQueue.length = 0;
    if (factory)
      await runWithSuite(collector, () => factory(test2));
    const allChildren = await Promise.all([...factoryQueue, ...tasks].map((i) => i.type === "collector" ? i.collect(file) : i));
    suite2.file = file;
    suite2.tasks = allChildren;
    allChildren.forEach((task) => {
      task.suite = suite2;
      if (file)
        task.file = file;
    });
    return suite2;
  }
  collectTask(collector);
  return collector;
}
function createSuite() {
  return createChainable(["concurrent", "skip", "only", "todo"], function(name, factory) {
    const mode = this.only ? "only" : this.skip ? "skip" : this.todo ? "todo" : "run";
    const computeMode = this.concurrent ? "concurrent" : void 0;
    return createSuiteCollector(name, factory, mode, computeMode);
  });
}

function equals(a, b, customTesters, strictCheck) {
  customTesters = customTesters || [];
  return eq(a, b, [], [], customTesters, strictCheck ? hasKey : hasDefinedKey);
}
function isAsymmetric(obj) {
  return !!obj && isA("Function", obj.asymmetricMatch);
}
function hasAsymmetric(obj, seen = /* @__PURE__ */ new Set()) {
  if (seen.has(obj))
    return false;
  seen.add(obj);
  if (isAsymmetric(obj))
    return true;
  if (Array.isArray(obj))
    return obj.some((i) => hasAsymmetric(i, seen));
  if (obj instanceof Set)
    return Array.from(obj).some((i) => hasAsymmetric(i, seen));
  if (isObject(obj))
    return Object.values(obj).some((v) => hasAsymmetric(v, seen));
  return false;
}
function asymmetricMatch(a, b) {
  const asymmetricA = isAsymmetric(a);
  const asymmetricB = isAsymmetric(b);
  if (asymmetricA && asymmetricB)
    return void 0;
  if (asymmetricA)
    return a.asymmetricMatch(b);
  if (asymmetricB)
    return b.asymmetricMatch(a);
}
function eq(a, b, aStack, bStack, customTesters, hasKey2) {
  let result = true;
  const asymmetricResult = asymmetricMatch(a, b);
  if (asymmetricResult !== void 0)
    return asymmetricResult;
  for (let i = 0; i < customTesters.length; i++) {
    const customTesterResult = customTesters[i](a, b);
    if (customTesterResult !== void 0)
      return customTesterResult;
  }
  if (a instanceof Error && b instanceof Error)
    return a.message === b.message;
  if (Object.is(a, b))
    return true;
  if (a === null || b === null)
    return a === b;
  const className = Object.prototype.toString.call(a);
  if (className !== Object.prototype.toString.call(b))
    return false;
  switch (className) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      if (typeof a !== typeof b) {
        return false;
      } else if (typeof a !== "object" && typeof b !== "object") {
        return Object.is(a, b);
      } else {
        return Object.is(a.valueOf(), b.valueOf());
      }
    case "[object Date]":
      return +a === +b;
    case "[object RegExp]":
      return a.source === b.source && a.flags === b.flags;
  }
  if (typeof a !== "object" || typeof b !== "object")
    return false;
  if (isDomNode(a) && isDomNode(b))
    return a.isEqualNode(b);
  let length = aStack.length;
  while (length--) {
    if (aStack[length] === a)
      return bStack[length] === b;
    else if (bStack[length] === b)
      return false;
  }
  aStack.push(a);
  bStack.push(b);
  if (className === "[object Array]" && a.length !== b.length)
    return false;
  const aKeys = keys(a, hasKey2);
  let key;
  let size = aKeys.length;
  if (keys(b, hasKey2).length !== size)
    return false;
  while (size--) {
    key = aKeys[size];
    result = hasKey2(b, key) && eq(a[key], b[key], aStack, bStack, customTesters, hasKey2);
    if (!result)
      return false;
  }
  aStack.pop();
  bStack.pop();
  return result;
}
function keys(obj, hasKey2) {
  const keys2 = [];
  for (const key in obj) {
    if (hasKey2(obj, key))
      keys2.push(key);
  }
  return keys2.concat(Object.getOwnPropertySymbols(obj).filter((symbol) => Object.getOwnPropertyDescriptor(obj, symbol).enumerable));
}
function hasDefinedKey(obj, key) {
  return hasKey(obj, key) && obj[key] !== void 0;
}
function hasKey(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isA(typeName, value) {
  return Object.prototype.toString.apply(value) === `[object ${typeName}]`;
}
function isDomNode(obj) {
  return obj !== null && typeof obj === "object" && typeof obj.nodeType === "number" && typeof obj.nodeName === "string" && typeof obj.isEqualNode === "function";
}
const IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
const IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
const IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
function isImmutableUnorderedKeyed(maybeKeyed) {
  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL] && !maybeKeyed[IS_ORDERED_SENTINEL]);
}
function isImmutableUnorderedSet(maybeSet) {
  return !!(maybeSet && maybeSet[IS_SET_SENTINEL] && !maybeSet[IS_ORDERED_SENTINEL]);
}
const IteratorSymbol = Symbol.iterator;
const hasIterator = (object) => !!(object != null && object[IteratorSymbol]);
const iterableEquality = (a, b, aStack = [], bStack = []) => {
  if (typeof a !== "object" || typeof b !== "object" || Array.isArray(a) || Array.isArray(b) || !hasIterator(a) || !hasIterator(b))
    return void 0;
  if (a.constructor !== b.constructor)
    return false;
  let length = aStack.length;
  while (length--) {
    if (aStack[length] === a)
      return bStack[length] === b;
  }
  aStack.push(a);
  bStack.push(b);
  const iterableEqualityWithStack = (a2, b2) => iterableEquality(a2, b2, [...aStack], [...bStack]);
  if (a.size !== void 0) {
    if (a.size !== b.size) {
      return false;
    } else if (isA("Set", a) || isImmutableUnorderedSet(a)) {
      let allFound = true;
      for (const aValue of a) {
        if (!b.has(aValue)) {
          let has = false;
          for (const bValue of b) {
            const isEqual = equals(aValue, bValue, [iterableEqualityWithStack]);
            if (isEqual === true)
              has = true;
          }
          if (has === false) {
            allFound = false;
            break;
          }
        }
      }
      aStack.pop();
      bStack.pop();
      return allFound;
    } else if (isA("Map", a) || isImmutableUnorderedKeyed(a)) {
      let allFound = true;
      for (const aEntry of a) {
        if (!b.has(aEntry[0]) || !equals(aEntry[1], b.get(aEntry[0]), [iterableEqualityWithStack])) {
          let has = false;
          for (const bEntry of b) {
            const matchedKey = equals(aEntry[0], bEntry[0], [
              iterableEqualityWithStack
            ]);
            let matchedValue = false;
            if (matchedKey === true) {
              matchedValue = equals(aEntry[1], bEntry[1], [
                iterableEqualityWithStack
              ]);
            }
            if (matchedValue === true)
              has = true;
          }
          if (has === false) {
            allFound = false;
            break;
          }
        }
      }
      aStack.pop();
      bStack.pop();
      return allFound;
    }
  }
  const bIterator = b[IteratorSymbol]();
  for (const aValue of a) {
    const nextB = bIterator.next();
    if (nextB.done || !equals(aValue, nextB.value, [iterableEqualityWithStack]))
      return false;
  }
  if (!bIterator.next().done)
    return false;
  aStack.pop();
  bStack.pop();
  return true;
};
const hasPropertyInObject = (object, key) => {
  const shouldTerminate = !object || typeof object !== "object" || object === Object.prototype;
  if (shouldTerminate)
    return false;
  return Object.prototype.hasOwnProperty.call(object, key) || hasPropertyInObject(Object.getPrototypeOf(object), key);
};
const isObjectWithKeys = (a) => isObject(a) && !(a instanceof Error) && !(a instanceof Array) && !(a instanceof Date);
const subsetEquality = (object, subset) => {
  const subsetEqualityWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object2, subset2) => {
    if (!isObjectWithKeys(subset2))
      return void 0;
    return Object.keys(subset2).every((key) => {
      if (isObjectWithKeys(subset2[key])) {
        if (seenReferences.has(subset2[key]))
          return equals(object2[key], subset2[key], [iterableEquality]);
        seenReferences.set(subset2[key], true);
      }
      const result = object2 != null && hasPropertyInObject(object2, key) && equals(object2[key], subset2[key], [
        iterableEquality,
        subsetEqualityWithContext(seenReferences)
      ]);
      seenReferences.delete(subset2[key]);
      return result;
    });
  };
  return subsetEqualityWithContext()(object, subset);
};
const typeEquality = (a, b) => {
  if (a == null || b == null || a.constructor === b.constructor)
    return void 0;
  return false;
};
const arrayBufferEquality = (a, b) => {
  if (!(a instanceof ArrayBuffer) || !(b instanceof ArrayBuffer))
    return void 0;
  const dataViewA = new DataView(a);
  const dataViewB = new DataView(b);
  if (dataViewA.byteLength !== dataViewB.byteLength)
    return false;
  for (let i = 0; i < dataViewA.byteLength; i++) {
    if (dataViewA.getUint8(i) !== dataViewB.getUint8(i))
      return false;
  }
  return true;
};
const sparseArrayEquality = (a, b) => {
  if (!Array.isArray(a) || !Array.isArray(b))
    return void 0;
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  return equals(a, b, [iterableEquality, typeEquality], true) && equals(aKeys, bKeys);
};

const MATCHERS_OBJECT = Symbol.for("matchers-object");
if (!Object.prototype.hasOwnProperty.call(global, MATCHERS_OBJECT)) {
  const defaultState = {
    assertionCalls: 0,
    expectedAssertionsNumber: null,
    expectedAssertionsNumberError: null
  };
  Object.defineProperty(global, MATCHERS_OBJECT, {
    value: {
      state: defaultState
    }
  });
}
const getState = () => global[MATCHERS_OBJECT].state;
const setState = (state) => {
  Object.assign(global[MATCHERS_OBJECT].state, state);
};
const JestChaiExpect = (chai, utils) => {
  function def(name, fn) {
    const addMethod = (n) => {
      utils.addMethod(chai.Assertion.prototype, n, fn);
    };
    if (Array.isArray(name))
      name.forEach((n) => addMethod(n));
    else
      addMethod(name);
  }
  const chaiEqual = chai.Assertion.prototype.equal;
  def("chaiEqual", function(...args) {
    return chaiEqual.apply(this, args);
  });
  utils.overwriteMethod(chai.Assertion.prototype, "equal", (_super) => {
    return function(...args) {
      const expected = args[0];
      const actual = utils.flag(this, "object");
      if (hasAsymmetric(expected)) {
        this.assert(equals(actual, expected, void 0, true), "not match with #{act}", "should not match with #{act}", actual, expected);
      } else {
        _super.apply(this, args);
      }
    };
  });
  utils.overwriteMethod(chai.Assertion.prototype, "eql", (_super) => {
    return function(...args) {
      const expected = args[0];
      const actual = utils.flag(this, "object");
      if (hasAsymmetric(expected)) {
        this.assert(equals(actual, expected), "not match with #{exp}", "should not match with #{exp}", actual, expected);
      } else {
        _super.apply(this, args);
      }
    };
  });
  def("toEqual", function(expected) {
    return this.eql(expected);
  });
  def("toStrictEqual", function(expected) {
    return iterableEquality(this, expected) ?? typeEquality(this, expected) ?? sparseArrayEquality(this, expected) ?? arrayBufferEquality(this, expected);
  });
  def("toBe", function(expected) {
    return this.equal(expected);
  });
  def("toMatchObject", function(expected) {
    return this.containSubset(expected);
  });
  def("toMatch", function(expected) {
    if (typeof expected === "string")
      return this.include(expected);
    else
      return this.match(expected);
  });
  def("toContain", function(item) {
    return this.contain(item);
  });
  def("toContainEqual", function(expected) {
    const obj = utils.flag(this, "object");
    const index = Array.from(obj).findIndex((item) => {
      try {
        chai.assert.deepEqual(item, expected);
      } catch {
        return false;
      }
      return true;
    });
    this.assert(index !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", expected);
  });
  def("toBeTruthy", function() {
    const obj = utils.flag(this, "object");
    this.assert(Boolean(obj), "expected #{this} to be truthy", "expected #{this} to not be truthy", obj);
  });
  def("toBeFalsy", function() {
    const obj = utils.flag(this, "object");
    this.assert(!obj, "expected #{this} to be falsy", "expected #{this} to not be falsy", obj);
  });
  def("toBeGreaterThan", function(expected) {
    return this.to.greaterThan(expected);
  });
  def("toBeGreaterThanOrEqual", function(expected) {
    return this.to.greaterThanOrEqual(expected);
  });
  def("toBeLessThan", function(expected) {
    return this.to.lessThan(expected);
  });
  def("toBeLessThanOrEqual", function(expected) {
    return this.to.lessThanOrEqual(expected);
  });
  def("toBeNaN", function() {
    return this.be.NaN;
  });
  def("toBeUndefined", function() {
    return this.be.undefined;
  });
  def("toBeNull", function() {
    return this.be.null;
  });
  def("toBeDefined", function() {
    return this.not.be.undefined;
  });
  def("toBeInstanceOf", function(obj) {
    return this.instanceOf(obj);
  });
  def("toHaveLength", function(length) {
    return this.have.length(length);
  });
  def("toHaveProperty", function(...args) {
    return this.have.deep.nested.property(...args);
  });
  def("toBeCloseTo", function(number, numDigits = 2) {
    utils.expectTypes(this, ["number"]);
    return this.closeTo(number, numDigits);
  });
  function isSpy(putativeSpy) {
    return typeof putativeSpy === "function" && "__isSpy" in putativeSpy && putativeSpy.__isSpy;
  }
  const assertIsMock = (assertion) => {
    if (!isSpy(assertion._obj))
      throw new TypeError(`${utils.inspect(assertion._obj)} is not a spy or a call to a spy!`);
  };
  const getSpy = (assertion) => {
    assertIsMock(assertion);
    return assertion._obj;
  };
  def(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(number) {
    const spy = getSpy(this);
    return this.assert(spy.callCount === number, "expected spy to be called #{exp} times", "expected spy to not be called #{exp} times", number, spy.callCount);
  });
  def("toHaveBeenCalledOnce", function() {
    const spy = getSpy(this);
    return this.assert(spy.callCount === 1, "expected spy to be called once", "expected spy to not be called once", 1, spy.callCount);
  });
  def(["toHaveBeenCalled", "toBeCalled"], function() {
    const spy = getSpy(this);
    return this.assert(spy.called, "expected spy to be called at least once", "expected spy to not be called at all", true, spy.called);
  });
  def(["toHaveBeenCalledWith", "toBeCalledWith"], function(...args) {
    const spy = getSpy(this);
    const pass = spy.calls.some((callArg) => equals(callArg, args));
    return this.assert(pass, "expected spy to be called with arguments: #{exp}", "expected spy to not be called with arguments: #{exp}", args, spy.calls);
  });
  const ordinalOf = (i) => {
    const j = i % 10;
    const k = i % 100;
    if (j === 1 && k !== 11)
      return `${i}st`;
    if (j === 2 && k !== 12)
      return `${i}nd`;
    if (j === 3 && k !== 13)
      return `${i}rd`;
    return `${i}th`;
  };
  def(["toHaveBeenNthCalledWith", "nthCalledWith"], function(times, ...args) {
    const spy = getSpy(this);
    const nthCall = spy.calls[times - 1];
    this.assert(equals(nthCall, args), `expected ${ordinalOf(times)} spy call to have been called with #{exp}`, `expected ${ordinalOf(times)} spy call to not have been called with #{exp}`, args, nthCall);
  });
  def(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...args) {
    const spy = getSpy(this);
    const lastCall = spy.calls[spy.calls.length - 1];
    this.assert(equals(lastCall, args), "expected last spy call to have been called with #{exp}", "expected last spy call to not have been called with #{exp}", args, lastCall);
  });
  def(["toThrow", "toThrowError"], function(expected) {
    const negate = utils.flag(this, "negate");
    if (negate)
      this.not.to.throw(expected);
    else
      this.to.throw(expected);
  });
  def(["toHaveReturned", "toReturn"], function() {
    const spy = getSpy(this);
    const calledAndNotThrew = spy.called && !spy.results.some(([type]) => type === "error");
    this.assert(calledAndNotThrew, "expected spy to be successfully called at least once", "expected spy to not be successfully called", calledAndNotThrew, !calledAndNotThrew);
  });
  def(["toHaveReturnedTimes", "toReturnTimes"], function(times) {
    const spy = getSpy(this);
    const successfullReturns = spy.results.reduce((success, [type]) => type === "error" ? success : ++success, 0);
    this.assert(successfullReturns === times, `expected spy to be successfully called ${times} times`, `expected spy to not be successfully called ${times} times`, `expected number of returns: ${times}`, `received number of returns: ${successfullReturns}`);
  });
  def(["toHaveReturnedWith", "toReturnWith"], function(value) {
    const spy = getSpy(this);
    const pass = spy.results.some(([type, result]) => type === "ok" && equals(value, result));
    this.assert(pass, "expected spy to be successfully called with #{exp}", "expected spy to not be successfully called with #{exp}", value);
  });
  def(["toHaveLastReturnedWith", "lastReturnedWith"], function(value) {
    const spy = getSpy(this);
    const lastResult = spy.returns[spy.returns.length - 1];
    const pass = equals(lastResult, value);
    this.assert(pass, "expected last spy call to return #{exp}", "expected last spy call to not return #{exp}", value, lastResult);
  });
  def(["toHaveNthReturnedWith", "nthReturnedWith"], function(nthCall, value) {
    const spy = getSpy(this);
    const isNot = utils.flag(this, "negate");
    const [callType, callResult] = spy.results[nthCall - 1];
    const ordinalCall = `${ordinalOf(nthCall)} call`;
    if (!isNot && callType === "error")
      chai.assert.fail(`expected ${ordinalCall} to return #{exp}, but instead it threw an error`);
    const nthCallReturn = equals(callResult, value);
    this.assert(nthCallReturn, `expected ${ordinalCall} spy call to return #{exp}`, `expected ${ordinalCall} spy call to not return #{exp}`, value, callResult);
  });
  utils.addMethod(chai.expect, "assertions", function assertions(expected) {
    const error = new Error(`expected number of assertions to be ${expected}, but got ${getState().assertionCalls}`);
    if (Error.captureStackTrace)
      Error.captureStackTrace(error, assertions);
    setState({
      expectedAssertionsNumber: expected,
      expectedAssertionsNumberError: error
    });
  });
};

var mockdate$1 = {exports: {}};

(function (module, exports) {
(function (global, factory) {
    factory(exports) ;
}(commonjsGlobal, (function (exports) {
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var RealDate = Date;
    var now = null;
    var MockDate = /** @class */ (function (_super) {
        __extends(Date, _super);
        function Date(y, m, d, h, M, s, ms) {
            _super.call(this) || this;
            var date;
            switch (arguments.length) {
                case 0:
                    if (now !== null) {
                        date = new RealDate(now.valueOf());
                    }
                    else {
                        date = new RealDate();
                    }
                    break;
                case 1:
                    date = new RealDate(y);
                    break;
                default:
                    d = typeof d === 'undefined' ? 1 : d;
                    h = h || 0;
                    M = M || 0;
                    s = s || 0;
                    ms = ms || 0;
                    date = new RealDate(y, m, d, h, M, s, ms);
                    break;
            }
            return date;
        }
        return Date;
    }(RealDate));
    MockDate.prototype = RealDate.prototype;
    MockDate.UTC = RealDate.UTC;
    MockDate.now = function () {
        return new MockDate().valueOf();
    };
    MockDate.parse = function (dateString) {
        return RealDate.parse(dateString);
    };
    MockDate.toString = function () {
        return RealDate.toString();
    };
    function set(date) {
        var dateObj = new Date(date.valueOf());
        if (isNaN(dateObj.getTime())) {
            throw new TypeError('mockdate: The time set is an invalid date: ' + date);
        }
        // @ts-ignore
        Date = MockDate;
        now = dateObj.valueOf();
    }
    function reset() {
        Date = RealDate;
    }
    var mockdate = {
        set: set,
        reset: reset,
    };

    exports.default = mockdate;
    exports.reset = reset;
    exports.set = set;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
}(mockdate$1, mockdate$1.exports));

var mockdate = /*@__PURE__*/getDefaultExportFromCjs(mockdate$1.exports);

const originalSetTimeout = global.setTimeout;
const originalSetInterval = global.setInterval;
const originalClearTimeout = global.clearTimeout;
const originalClearInterval = global.clearInterval;
const MAX_LOOPS = 1e4;
const assertEvery = (assertions, message) => {
  if (assertions.some((a) => !a))
    throw new Error(message);
};
const assertMaxLoop = (times) => {
  if (times >= MAX_LOOPS)
    throw new Error("setTimeout/setInterval called 10 000 times. It's possible it stuck in an infinite loop.");
};
const getNodeTimeout = (id) => {
  const timer = {
    ref: () => timer,
    unref: () => timer,
    hasRef: () => true,
    refresh: () => timer,
    [Symbol.toPrimitive]: () => id
  };
  return timer;
};
class FakeTimers {
  constructor() {
    this._advancedTime = 0;
    this._nestedTime = {};
    this._scopeId = 0;
    this._isNested = false;
    this._isOnlyPending = false;
    this._spyid = 0;
    this._isMocked = false;
    this._tasksQueue = [];
    this._queueCount = 0;
  }
  useFakeTimers() {
    this._isMocked = true;
    this.reset();
    const spyFactory = (spyType, resultBuilder) => {
      return (cb, ms = 0) => {
        const id = ++this._spyid;
        const nestedTo = Object.entries(this._nestedTime).filter(([key]) => Number(key) <= this._scopeId);
        const nestedMs = nestedTo.reduce((total, [, ms2]) => total + ms2, ms);
        const call = { id, cb, ms, nestedMs, scopeId: this._scopeId };
        const task = { type: spyType, call, nested: this._isNested };
        this.pushTask(task);
        return resultBuilder(id, cb);
      };
    };
    this._setTimeout = spyOn(global, "setTimeout").mockImplementation(spyFactory("timeout" /* Timeout */, getNodeTimeout));
    this._setInterval = spyOn(global, "setInterval").mockImplementation(spyFactory("interval" /* Interval */, getNodeTimeout));
    const clearTimerFactory = (spyType) => (id) => {
      if (id === void 0)
        return;
      const index = this._tasksQueue.findIndex(({ call, type }) => type === spyType && call.id === Number(id));
      if (index !== -1)
        this._tasksQueue.splice(index, 1);
    };
    this._clearTimeout = spyOn(global, "clearTimeout").mockImplementation(clearTimerFactory("timeout" /* Timeout */));
    this._clearInterval = spyOn(global, "clearInterval").mockImplementation(clearTimerFactory("interval" /* Interval */));
  }
  useRealTimers() {
    this._isMocked = false;
    this.reset();
    global.setTimeout = originalSetTimeout;
    global.setInterval = originalSetInterval;
    global.clearTimeout = originalClearTimeout;
    global.clearInterval = originalClearInterval;
  }
  runOnlyPendingTimers() {
    this.assertMocked();
    this._isOnlyPending = true;
    this.runQueue();
  }
  runAllTimers() {
    this.assertMocked();
    this.runQueue();
  }
  advanceTimersByTime(ms) {
    this.assertMocked();
    this._advancedTime += ms;
    this.runQueue();
  }
  advanceTimersToNextTimer() {
    this.assertMocked();
    this.callQueueItem(0);
  }
  getTimerCount() {
    this.assertMocked();
    return this._tasksQueue.length;
  }
  reset() {
    var _a, _b, _c, _d;
    this._advancedTime = 0;
    this._nestedTime = {};
    this._isNested = false;
    this._isOnlyPending = false;
    this._spyid = 0;
    this._queueCount = 0;
    this._tasksQueue = [];
    (_a = this._clearInterval) == null ? void 0 : _a.mockRestore();
    (_b = this._clearTimeout) == null ? void 0 : _b.mockRestore();
    (_c = this._setInterval) == null ? void 0 : _c.mockRestore();
    (_d = this._setTimeout) == null ? void 0 : _d.mockRestore();
  }
  callQueueItem(index) {
    var _a, _b;
    const task = this._tasksQueue[index];
    if (!task)
      return;
    const { call, type } = task;
    this._scopeId = call.id;
    this._isNested = true;
    (_a = this._nestedTime)[_b = call.id] ?? (_a[_b] = 0);
    this._nestedTime[call.id] += call.ms;
    if (type === "timeout") {
      this.removeTask(index);
    } else if (type === "interval") {
      call.nestedMs += call.ms;
      const nestedMs = call.nestedMs;
      const closestTask = this._tasksQueue.findIndex(({ type: type2, call: call2 }) => type2 === "interval" && call2.nestedMs < nestedMs);
      if (closestTask !== -1 && closestTask !== index)
        this.ensureQueueOrder();
    }
    call.cb();
    this._queueCount++;
  }
  runQueue() {
    let index = 0;
    while (this._tasksQueue[index]) {
      assertMaxLoop(this._queueCount);
      const { call, nested } = this._tasksQueue[index];
      if (this._advancedTime && call.nestedMs > this._advancedTime)
        break;
      if (this._isOnlyPending && nested) {
        index++;
        continue;
      }
      this.callQueueItem(index);
    }
  }
  removeTask(index) {
    if (index === 0)
      this._tasksQueue.shift();
    else
      this._tasksQueue.splice(index, 1);
  }
  pushTask(task) {
    this._tasksQueue.push(task);
    this.ensureQueueOrder();
  }
  ensureQueueOrder() {
    this._tasksQueue.sort((t1, t2) => {
      const diff = t1.call.nestedMs - t2.call.nestedMs;
      if (diff === 0) {
        if (t1.type === "immediate" /* Immediate */ && t2.type !== "immediate" /* Immediate */)
          return 1;
        return 0;
      }
      return diff;
    });
  }
  assertMocked() {
    assertEvery([
      this._isMocked,
      this._setTimeout,
      this._setInterval,
      this._clearTimeout,
      this._clearInterval
    ], 'timers are not mocked. try calling "vitest.useFakeTimers()" first');
  }
}

class VitestUtils {
  constructor() {
    this.spyOn = spyOn;
    this.fn = fn;
    this._timers = new FakeTimers();
    this._mockedDate = null;
  }
  useFakeTimers() {
    return this._timers.useFakeTimers();
  }
  useRealTimers() {
    return this._timers.useRealTimers();
  }
  runOnlyPendingTimers() {
    return this._timers.runOnlyPendingTimers();
  }
  runAllTimers() {
    return this._timers.runAllTimers();
  }
  advanceTimersByTime(ms) {
    return this._timers.advanceTimersByTime(ms);
  }
  advanceTimersToNextTimer() {
    return this._timers.advanceTimersToNextTimer();
  }
  getTimerCount() {
    return this._timers.getTimerCount();
  }
  mockCurrentDate(date) {
    this._mockedDate = date;
    mockdate.set(date);
  }
  restoreCurrentDate() {
    this._mockedDate = null;
    mockdate.reset();
  }
  getMockedDate() {
    return this._mockedDate;
  }
  mock(path, factory) {
  }
  unmock(path) {
  }
  async importActual(path) {
    return {};
  }
  async importMock(path) {
    return {};
  }
  mocked(item, _deep = false) {
    return item;
  }
  isMockFunction(fn2) {
    return typeof fn2 === "function" && "__isSpy" in fn2 && fn2.__isSpy;
  }
  clearAllMocks() {
    __vitest__clearMocks__({ clearMocks: true });
    spies.forEach((spy) => spy.mockClear());
    return this;
  }
  resetAllMocks() {
    __vitest__clearMocks__({ mockReset: true });
    spies.forEach((spy) => spy.mockReset());
    return this;
  }
  restoreAllMocks() {
    __vitest__clearMocks__({ restoreMocks: true });
    spies.forEach((spy) => spy.mockRestore());
    return this;
  }
}
const vitest = new VitestUtils();
const vi = vitest;

export { JestChaiExpect as J, getDefaultHookTimeout as a, getState as b, suite as c, describe as d, vi as e, equals as f, getCurrentSuite as g, iterableEquality as h, it as i, subsetEquality as j, isA as k, clearContext as l, defaultSuite as m, setHooks as n, getHooks as o, context as p, getFn as q, setState as s, test as t, vitest as v, withTimeout as w };
